# MPI exercise
 ## Introduction
 The purpose of this project is the implementation of a parallel mpi algorithm that reallocates some d-dimensonal points to a number of p processes depending on the distance of every point from the median Eucledian distance. In more detail , using the quickselect algorithm we have to split our points into two groups , those that have smaller and those that have bigger distance than the median distance (those with equal distances with the median distance are eligible for both groups) and create an “exchange board” that will allow our processes to concurrent swap information in order to achieve our final goal , which is the reallocation on of all data that belong to the small-distance group to the first p/2 processes and the big-distance data to the last p/2 processes.

 ## Implementation Analysis
  First of all, we implemented some “assistant” functions that will allow us to execute some vital activities for the operation of our program outside of the main function. The swap function does a simple swapping of two elements of an array, the find_dist function calculates the distance between two specific points and the partition and quick_select functions implement the common quick select sorting algorithm. Furthermore, find_final function gets as arguments the number of distances less (or more) than the median one and generates the board on which the exchanges are made. The code here is pretty simple, if we are exchanging smaller distances (flag = 0), starting from the processes with higher rank, which are supposed to give small distances, we fill each process’ remaining spots and then moving on to the next one and so on. The board generated is p x (3 *p/2), p is the number of processes, each line represents the elements the process which has the same rank as the number of the line has to send and the board contains 3 elements to make this happen(start, end, receiver). The results, of how many “small” and “big” points each process contains are generated by the distribute func>on that simply moves the small distances on the left and the big ones on the right and returns the turning point. Also, distribute uses the swap function in order to swap two d-dimentional elements.
Now moving on to the distributeByMedian function , the principal function of our program, this function does exactly what is stated in the description of the task, the “master” process is getting the distances calculated from all the other processes, finds the median distance sending it back to the others. Then all the processes distribute their points and send a result value back to the “master” process, information which is used for finding the exchange table, as described above. Finally, all the processes have the exchange table and send and receive the points needed.
Last but not least, in main function, the process with rank 0 reads all points in mint.bin file and sends n/p points to each process. Then, using the controll_recursion function we call recursively he distributeByMedian in order to achieve the final goal: each process’ points are smaller than the next processes’ points. In the end, the process with rank 0 gets the maximum and the minimum distance of each process and checks if the result is correct.

 ## Measurements
 <img width="773" alt="Screenshot 2022-03-26 at 7 43 58 PM" src="https://user-images.githubusercontent.com/81708900/160251223-7aea2c61-7642-4827-91e1-b3dfb8cc0ceb.png">
 As we see in the graph despite the increase of communications and levels of recursion when running our algorithm using more processes we can see that the total runtime is decreased, showing the benefits of working with multiple processes and separate memories using mpi.

